<<<<<<< HEAD
//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html
=======
/*****************************************/
/* Written by andrew.wilkins@csiro.au    */
/* Please contact me if you make changes */
/*****************************************/
>>>>>>> d297f50cb1 (Merging Modules into MOOSE #2460)

#include "RichardsExcavFlow.h"
#include "Function.h"
#include "Material.h"

<<<<<<< HEAD
registerMooseObject("RichardsApp", RichardsExcavFlow);

InputParameters
RichardsExcavFlow::validParams()
{
  InputParameters params = SideIntegralVariablePostprocessor::validParams();
  params.addRequiredParam<FunctionName>(
      "excav_geom_function",
      "The function describing the excavation geometry (type RichardsExcavGeom)");
  params.addRequiredParam<UserObjectName>(
      "richardsVarNames_UO", "The UserObject that holds the list of Richards variable names.");
  params.addClassDescription("Records total flow INTO an excavation (if quantity is positive then "
                             "flow has occured from rock into excavation void)");
  return params;
}

RichardsExcavFlow::RichardsExcavFlow(const InputParameters & parameters)
  : SideIntegralVariablePostprocessor(parameters),

    _richards_name_UO(getUserObject<RichardsVarNames>("richardsVarNames_UO")),
    _pvar(_richards_name_UO.richards_var_num(coupled("variable"))),

    _flux(getMaterialProperty<std::vector<RealVectorValue>>("flux")),

    _func(getFunction("excav_geom_function"))
{
}
=======
template<>
InputParameters validParams<RichardsExcavFlow>()
{
  InputParameters params = validParams<SideIntegralVariablePostprocessor>();
  params.addRequiredParam<FunctionName>("excav_geom_function", "The function describing the excavation geometry (type RichardsExcavGeom)");
  params.addRequiredParam<UserObjectName>("porepressureNames_UO", "The UserObject that holds the list of porepressure names.");
  params.addClassDescription("Records total flow INTO an excavation (if quantity is positive then flow has occured from rock into excavation void)");
  return params;
}

RichardsExcavFlow::RichardsExcavFlow(const std::string & name, InputParameters parameters) :
    SideIntegralVariablePostprocessor(name, parameters),
    FunctionInterface(parameters),

    _pp_name_UO(getUserObject<RichardsPorepressureNames>("porepressureNames_UO")),
    _pvar(_pp_name_UO.pressure_var_num(_var.index())),

    _viscosity(getMaterialProperty<std::vector<Real> >("viscosity")),
    _gravity(getMaterialProperty<RealVectorValue>("gravity")),
    _permeability(getMaterialProperty<RealTensorValue>("permeability")),
    _rel_perm(getMaterialProperty<std::vector<Real> >("rel_perm")),
    _density(getMaterialProperty<std::vector<Real> >("density")),
    _func(getFunction("excav_geom_function"))
{}
>>>>>>> d297f50cb1 (Merging Modules into MOOSE #2460)

Real
RichardsExcavFlow::computeQpIntegral()
{
<<<<<<< HEAD
  return -_func.value(_t, _q_point[_qp]) * _normals[_qp] * _flux[_qp][_pvar] * _dt;
=======
  return -_func.value(_t, _q_point[_qp])*_normals[_qp]*((_density[_qp][_pvar]*_rel_perm[_qp][_pvar]/_viscosity[_qp][_pvar])*(_permeability[_qp]*(_grad_u[_qp] - _density[_qp][_pvar]*_gravity[_qp])))*_dt ;
>>>>>>> d297f50cb1 (Merging Modules into MOOSE #2460)
}
